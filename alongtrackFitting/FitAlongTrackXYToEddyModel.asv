function params = FitAlongTrackXYToEddyModel(alongtrack, eddyFit_fun, initialParams, options)
arguments
    alongtrack struct
    eddyFit_fun function_handle
    initialParams struct
    options.LB (1,1) double = []
    options.UB (1,1) double = []
end
use alongtrack
use options
if exist(LB)
model_eddy=eddyFit_fun;

p(1)=initialParams.A;
p(2)=initialParams.L;
p(3)=initialParams.x0;
p(4)=initialParams.y0;
p(5)=initialParams.cx;
p(6)=initialParams.cy;
penalty_function = @(p) mean((ssh - model_eddy(x,y,t,p(1),p(2),p(3),p(4),p(5),p(6))).^2);
it_options = optimset('OutputFcn', @plotIterP,'TolX',0.1,'TolFun',1);

% feed in slightly worse values. These values are terribly scaled, but it
% seems to return exactly the right value anyway.
p0 = [0.13, 85e3, 450e3, 50e3, -2e3, -0,3e3];
pmin=fminsearchbnd(penalty_function, p0, LB, UB, it_options);

params.A=pmin(1);
params.L=pmin(2);
params.x0=pmin(3);
params.y0=pmin(4);
params.cx=pmin(5);
params.cy=pmin(6);

th = 0:pi/50:2*pi;
tmat = t-t(1);

% True positions
xo_true = p0(3) + p0(4)*tmat(end);
yo_true = p0(5) + p0(6)*tmat(end);

% Fit position
xo_fit = p(3) + p(4)*tmat(end);
yo_fit = p(5) + p(6)*tmat(end);

figure;hold on
plot(p0(2)*sin(th)+xo_true, p0(2)*cos(th)+yo_true,'r--');
plot(p(2)*sin(th)+xo_fit, p(2)*cos(th)+yo_fit,'b');
plot(xo_true, yo_true,'r*');
plot(xo_fit, yo_fit,'b*');
axis equal
xlim([min(x),max(x)]);ylim([min(y),max(y)])
box on
legend('True position', 'Fit position')
% Calculate error
position_error = sqrt((xo_fit - xo_true).^2 + (yo_fit - yo_true).^2);